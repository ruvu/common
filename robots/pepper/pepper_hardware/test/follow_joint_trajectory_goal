#!/usr/bin/env python

import argparse

import rospy
import actionlib

from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint


def send_follow_joint_trajectory_action_goal(joint_positions):
    client = actionlib.SimpleActionClient('follow_joint_trajectory', FollowJointTrajectoryAction)
    client.wait_for_server()

    # Creates a goal to send to the action server.
    goal = FollowJointTrajectoryGoal()
    goal.trajectory.joint_names = joint_positions.keys()
    goal.trajectory.points = [JointTrajectoryPoint(positions=joint_positions.values())]

    # Sends the goal to the action server.
    client.send_goal(FollowJointTrajectoryGoal(
        trajectory=JointTrajectory(
            joint_names=joint_positions.keys(),
            points=[JointTrajectoryPoint(positions=joint_positions.values())]
        )
    ))

    # Waits for the server to finish performing the action.
    client.wait_for_result()

    # Prints out the result of executing the action
    print client.get_result()


if __name__ == "__main__":
    rospy.init_node("follow_joint_trajectory_goal", anonymous=True)

    parser = argparse.ArgumentParser(description='Send a follow trajectory action goal')
    parser.add_argument('JOINT_POSITION', nargs='+', action=type('', (argparse.Action,), dict(
        __call__=lambda a, p, n, v, o: getattr(n, a.dest).update(dict([e.split('=') for e in v])))),
                        default={})  # anonymously subclassing argparse.Action

    args = parser.parse_args()

    try:
        joint_positions = dict([(str(k), float(v)) for k, v in args.JOINT_POSITION.iteritems()])
    except ValueError as e:
        rospy.logerr("All name position pairs should be pairs of string and floats, {}".format(e))
        rospy.signal_shutdown()
    else:
        send_follow_joint_trajectory_action_goal(joint_positions)