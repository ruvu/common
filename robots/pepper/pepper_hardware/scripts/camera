#!/usr/bin/env python

# MIT License
#
# Copyright (c) 2017 RUVU Robotics
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import sys

from camera_info_manager import CameraInfoManager
import rospy
from cv_bridge import CvBridge
import numpy as np

from std_msgs.msg import Header
from sensor_msgs.msg import Image, CameraInfo

from pepper_hardware import QiSession

ENCODING_MAP = {
    "bgr8": 13,
    "16UC1": 17
}
ENCODING_MAP_REVERSED = dict([(v, k) for k, v in ENCODING_MAP.iteritems()])

RESOLUTION_MAP = {
    "40x30": 8,
    "80x60": 7,
    "160x120": 0,
    "320x240": 1,
    "640x480": 2,
    "1280x960": 3,
    "2560x1920": 4
}


class Camera:

    def __init__(self):
        """
        Camera for the Pepper Robot
        """
        self._session = QiSession()
        self._video_device = self._session.get_service("ALVideoDevice")
        self._bridge = CvBridge()

        camera_indices = self._video_device.getCameraIndexes()
        camera_index = rospy.get_param("~camera_index", 0)
        if camera_index not in camera_indices:
            rospy.logerr("Camera index not in available camera indices: {}".format(camera_indices))
            sys.exit(1)

        self._encoding = rospy.get_param("~encoding", "bgr8")
        if self._encoding not in ENCODING_MAP:
            rospy.logerr("Unsupported encoding. Supported encodings: {}".format(ENCODING_MAP.keys()))
            sys.exit(1)

        frame_rate = rospy.get_param("~frame_rate", 15)
        resolution = rospy.get_param("~resolution", "640x480")
        if resolution not in RESOLUTION_MAP:
            rospy.logerr("Unsupported resolution. Supported resolutions: {}".format(RESOLUTION_MAP.keys()))
            sys.exit(1)

        name = "ros_camera_index_{}".format(camera_index)
        self._unsubscribe_stale_subscribers(name)
        self._camera_name = self._video_device.subscribeCamera(name, camera_index, RESOLUTION_MAP[resolution],
                                                               ENCODING_MAP[self._encoding], frame_rate)

        self._frame_id = rospy.get_param("~frame_id", "camera")

        self._image_publisher = rospy.Publisher("image", Image, queue_size=1)
        self._camera_info_publisher = rospy.Publisher("camera_info", CameraInfo, queue_size=1)
        self._camera_info_manager = CameraInfoManager(rospy.get_param("~name", "camera"),
                                                      rospy.get_param("~camera_info_url", ""))
        self._camera_info_manager.loadCameraInfo()

    def _unsubscribe_stale_subscribers(self, match):
        for name in self._video_device.getSubscribers():
            if match in name:
                self._video_device.unsubscribe(name)

    def spin(self):
        while not rospy.is_shutdown():
            image = self._video_device.getImageRemote(self._camera_name)

            if image is None:
                rospy.logwarn("Could not grab image!")
                continue

            width, height, number_of_layers, encoding, _, _, data, _, _, _, _, _ = image

            if encoding != ENCODING_MAP[self._encoding]:
                rospy.logerr("Received different encoding ({}) than expected ({})."
                             .format(encoding, ENCODING_MAP[self._encoding]))
                continue

            header = Header(
                stamp=rospy.Time.now(),
                frame_id=self._frame_id
            )

            image_msg = Image(
                header=header,
                width=width,
                height=height,
                encoding=self._encoding,
                step=width * number_of_layers,
                data=list(data)
            )

            # For 16UC1 depth images (in mm), we need to convert to 32FC1 and meters to comply with ROS standards
            if self._encoding == "16UC1":
                image_msg.data = data

                cv_img = self._bridge.imgmsg_to_cv2(image_msg, desired_encoding="32FC1")
                cv_img = np.divide(cv_img, 1000)
                image_msg = self._bridge.cv2_to_imgmsg(cv_img, encoding="32FC1")
                image_msg.header = header

            camera_info_msg = self._camera_info_manager.getCameraInfo()
            camera_info_msg.header = header

            self._image_publisher.publish(image_msg)
            self._camera_info_publisher.publish(camera_info_msg)

if __name__ == "__main__":
    rospy.init_node("camera")
    cam = Camera()
    cam.spin()
