#!/usr/bin/env python
import Queue
import socket
import threading
from functools import partial

import pika
import rospy
from rospy_message_converter import json_message_converter
from ruvu_rabbitmq_bridge import get_topic_name_msg_type_dict


class RabbitMQBridge(object):
    def __init__(self, subscribers, publishers, rabbitmq_host, rabbitmq_username, rabbitmq_password,
                 rabbitmq_queue_prefix, ros_publisher_queue_size, queue_empty_timeout):
        """
        RabbitMQ ROS Bridge that bridges between the ROS and the RabbitMQ network
        :param subscribers: Dictionary that maps topic_names to message types, subscribers on the ROS end
        :param publishers: Dictionary that maps topic_names to message types, publishers on the ROS end
        :param rabbitmq_host: Specifies where the RabbitMQ server is running
        :param rabbitmq_username: The RabbitMQ username
        :param rabbitmq_password: The RabbitMQ password
        :param rabbitmq_queue_prefix: The ROS topic names equal the RabbitMQ queue names but prepended with this prefix
        :param ros_publisher_queue_size: ROS publisher queue size
        :param queue_empty_timeout: When there is no incoming ROS message, wait for x seconds
        """
        self._ros_subscribers = {}
        self._ros_publishers = {}
        self._rabbitmq_subscribers = {}
        self._rabbitmq_publishers = {}
        self._rabbitmq_queue_prefix = rabbitmq_queue_prefix + "/" if rabbitmq_queue_prefix else ""
        self._queue_empty_timeout = queue_empty_timeout

        if rabbitmq_username:
            parameters = pika.ConnectionParameters(host=rabbitmq_host,
                                                   credentials=pika.PlainCredentials(rabbitmq_username,
                                                                                     rabbitmq_password))
            rospy.loginfo("Connecting to {} (with credentials)".format(rabbitmq_host))
        else:
            parameters = pika.ConnectionParameters(host=rabbitmq_host)
            rospy.loginfo("Connecting to {}".format(rabbitmq_host))
        self._rabbitmq_write_connection = pika.BlockingConnection(parameters)
        self._rabbitmq_write_channel = self._rabbitmq_write_connection.channel()

        self._rabbitmq_read_connection = pika.BlockingConnection(parameters)
        self._rabbitmq_read_channel = self._rabbitmq_read_connection.channel()

        self._ros_q = Queue.Queue()  # input queue for ROS msgs
        for topic_name, topic_msg_type in subscribers.iteritems():
            # Create ROS subscriber
            self._ros_subscribers[topic_name] = rospy.Subscriber(
                topic_name, topic_msg_type, partial(self._ros_msg_callback, topic_name)
            )

            # Create RabbitMQ Publisher
            rabbitmq_queue_name = self._rabbitmq_queue_prefix + topic_name
            self._rabbitmq_write_channel.queue_declare(queue=rabbitmq_queue_name)

        for topic_name, topic_msg_type in publishers.iteritems():
            # Create ROS publisher
            self._ros_publishers[topic_name] = rospy.Publisher(
                topic_name, topic_msg_type, queue_size=ros_publisher_queue_size
            )

            # Create RabbitMQ subscriber
            rabbitmq_queue_name = self._rabbitmq_queue_prefix + topic_name
            self._rabbitmq_read_channel.queue_declare(queue=rabbitmq_queue_name)
            self._rabbitmq_read_channel.basic_consume(self._rabbitmq_msg_callback, queue=rabbitmq_queue_name,
                                                      no_ack=True)

    def _ros_msg_callback(self, topic_name, msg):
        """
        Message callback of incoming ROS message
        :param topic_name: Topic on which the msg was received
        :param msg: Incoming message
        """
        self._ros_q.put((topic_name, msg))

    def _publish_ros_msg_rabbitmq(self, topic_name, msg):
        rabbitmq_queue_name = self._rabbitmq_queue_prefix + topic_name
        body = json_message_converter.convert_ros_message_to_json(msg)
        rospy.logdebug(
            "Publishing RabbitMQ message with body {} to queue {}".format(body, rabbitmq_queue_name))
        self._rabbitmq_write_channel.basic_publish(
            exchange='',
            routing_key=rabbitmq_queue_name,
            body=body
        )

    def _rabbitmq_msg_callback(self, channel, method, properties, body):
        """
        Message callback when a message is read out of the RabbitMQ queue
        :param channel: Reference to the RabbitMQ channel
        :param method: RabbitMQ method
        :param properties: Message properties
        :param body: Incoming message contents
        """
        if method.routing_key.startswith(self._rabbitmq_queue_prefix):
            topic_name = method.routing_key[len(self._rabbitmq_queue_prefix):]

            publisher = self._ros_publishers[topic_name]
            try:
                msg = json_message_converter.convert_json_to_ros_message(publisher.type, body)
            except ValueError as e:
                rospy.logerr("Conversion to ROS msg failed: {}".format(e))
            else:
                rospy.logdebug("Publishing ROS message {} to topic {}".format(topic_name, msg))
                publisher.publish(msg)
        else:
            rospy.logerr('Route key %s not prefixed by %s', method.routing_key, self._rabbitmq_queue_prefix)

    def _ros_msg_handler_thread(self):
        while not rospy.is_shutdown():
            try:
                self._publish_ros_msg_rabbitmq(*self._ros_q.get(timeout=self._queue_empty_timeout))
            except Queue.Empty:
                pass

    def spin(self):
        """
        Spins the bridge, starts the read channel and makes sure that a shutdown is handled properly.
        """

        def shutdown_hook():
            rospy.loginfo("Shutting down RabbitMQ read channel ...")
            self._rabbitmq_read_channel.stop_consuming()

        rospy.on_shutdown(shutdown_hook)

        rospy.loginfo("RabbitMQBridge initialized. Start consuming RabbitMQ read channel & ROS msg handler thread")

        ros_msg_handler_thread = threading.Thread(target=self._ros_msg_handler_thread)
        ros_msg_handler_thread.start()
        self._rabbitmq_read_channel.start_consuming()

        ros_msg_handler_thread.join()

        rospy.loginfo("RabbitMQBridge stopped")


if __name__ == '__main__':
    rospy.init_node('rabbitmq_bridge')

    bridge = RabbitMQBridge(
        get_topic_name_msg_type_dict(rospy.get_param('~subscribers')),
        get_topic_name_msg_type_dict(rospy.get_param('~publishers')),
        rospy.get_param('~rabbitmq_host', 'localhost'),
        rospy.get_param('~rabbitmq_username', ''),
        rospy.get_param('~rabbitmq_password', ''),
        rospy.get_param('~rabbitmq_queue_prefix', socket.gethostname()),
        rospy.get_param('~ros_publisher_queue_size', 10),
        rospy.get_param('~queue_empty_timeout', 0.01)
    )
    bridge.spin()
